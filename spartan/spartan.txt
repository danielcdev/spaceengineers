public abstract class Serializable {
	protected abstract void toString(StringBuilder stringBuilder);
	protected abstract void fromString();
}

public class Serializer {

}

public class Deserializer {
	public Deserializer(string serialized) {

	}
}

public interface Observable<T> {
	void subscribe(Observer<T> t);
}

public interface Observer<T> {
	void onNext(T t);
}

public enum OperatingModeType {
	UNDEFINED, LONG_TERM_STANDBY, STANDBY, GROUND, FLIGHT
}

public enum SensorEventType {
	UNDEFINED, TAKEOFF, APPROACH
}

public class OperatingMode {
	public OperatingModeType operatingModeType { get; set; }

	public OperatingMode() {
		operatingModeType = OperatingModeType.UNDEFINED;
	}

	public string convert(OperatingModeType operatingModeType) {
		switch (operatingModeType) {
			case OperatingModeType.UNDEFINED:
				return "UNDEFINED";

			case OperatingModeType.LONG_TERM_STANDBY:
				return "LONG_TERM_STANDBY";

			case OperatingModeType.STANDBY:
				return "STANDBY";

			case OperatingModeType.GROUND:
				return "GROUND";

			case OperatingModeType.FLIGHT:
				return "FLIGHT";

			default:
				return "UNDEFINED";
		}
	}

	public OperatingModeType convert(string operatingModeType) {
		switch (operatingModeType) {
			case "UNDEFINED":
				return OperatingModeType.UNDEFINED;

			case "LONG_TERM_STANDBY":
				return OperatingModeType.LONG_TERM_STANDBY;

			case "STANDBY":
				return OperatingModeType.STANDBY;

			case "GROUND":
				return OperatingModeType.GROUND;

			case "FLIGHT":
				return OperatingModeType.FLIGHT;

			default:
				return OperatingModeType.UNDEFINED;
		}
	}
}

public class OperatingModeHandler : Observable<OperatingMode> {
	private List<Observer<OperatingMode>> observers = new List<Observer<OperatingMode>>();
	public OperatingMode operatingMode { get; private set; }

	public OperatingModeHandler() {
		operatingMode = new OperatingMode();
	}

	public OperatingModeHandler(OperatingMode operatingMode) {
		this.operatingMode = operatingMode;
	}

	public void subscribe(Observer<OperatingMode> observer) {
		if (!observers.Contains(observer))
			observers.Add(observer);
	}

	public void change(OperatingModeType operatingModeType) {
		if (operatingMode.operatingModeType == operatingModeType)
			return;

		operatingMode.operatingModeType = operatingModeType;

		foreach (var observer in observers)
			observer.onNext(operatingMode);
	}
}

public class SensorEvent {
	public SensorEventType sensorEventType { get; private set; }

	public SensorEvent(SensorEventType sensorEventType) {
		this.sensorEventType = sensorEventType;
	}

	public string convert(SensorEventType sensorEventType) {
		switch (sensorEventType) {
			case SensorEventType.UNDEFINED:
				return "UNDEFINED";

			case SensorEventType.TAKEOFF:
				return "TAKEOFF";

			case SensorEventType.APPROACH:
				return "APPROACH";

			default:
				return "UNDEFINED";
		}
	}

	public SensorEventType convert(string sensorEventType) {
		switch (sensorEventType) {
			case "UNDEFINED":
				return SensorEventType.UNDEFINED;

			case "TAKEOFF":
				return SensorEventType.TAKEOFF;

			case "APPROACH":
				return SensorEventType.APPROACH;

			default:
				return SensorEventType.UNDEFINED;
		}
	}
}

public class SensorEventHandler : Observable<SensorEvent> {
	private List<Observer<SensorEvent>> observers = new List<Observer<SensorEvent>>();
	private OperatingModeHandler operatingModeHandler;
	private LocalTerminal localTerminal;

	public SensorEventHandler(OperatingModeHandler operatingModeHandler, LocalTerminal localTerminal) {
		this.operatingModeHandler = operatingModeHandler;
		this.localTerminal = localTerminal;
	}

	public void subscribe(Observer<SensorEvent> observer) {
		if (!observers.Contains(observer))
			observers.Add(observer);
	}

	public void fire(SensorEvent sensorEvent) {
		foreach (var observer in observers)
			observer.onNext(sensorEvent);
	}
}

public class DebugEvent {
	public string message { get; private set; }

	public DebugEvent(string message) {
		if (string.IsNullOrEmpty(message))
			this.message = "[WARNING] Debug Event fired with empty message";
		else
			this.message = message;
	}

	public DebugEvent(Exception exception) {
		string exceptionMessage;

		if (exception == null || (exceptionMessage = exception.ToString()) == null || exceptionMessage.Length == 0) {
			message = "[WARNING] Debug Event fired with empty exception";
			return;
		}

		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append(exceptionMessage);

		while ((exception = exception.InnerException) != null)
			stringBuilder.Append(exception.ToString());

		message = stringBuilder.ToString();
	}
}

public class DebugEventHandler : Observable<DebugEvent> {
	private List<Observer<DebugEvent>> observers = new List<Observer<DebugEvent>>();

	public void subscribe(Observer<DebugEvent> observer) {
		if (!observers.Contains(observer))
			observers.Add(observer);
	}

	public void fire(DebugEvent debugEvent) {
		foreach (var observer in observers)
			observer.onNext(debugEvent);
	}
}

public class DebugTerminal : Observer<DebugEvent> {
	private List<IMyTextPanel> debugTerminals = new List<IMyTextPanel>();
	private bool debugSystemActive = false;

	public DebugTerminal(Program program, DebugEventHandler debugEventHandler) {
		if (program == null)
			return;

		if (debugEventHandler == null) {
			program.Echo("[SEVERE] DebugEventHandler was not properly instantiated");
			return;
		}

		program.GridTerminalSystem.GetBlocksOfType(debugTerminals, textPanel => textPanel.CustomData.Contains("SSMS debug"));

		if (debugTerminals == null || debugTerminals.Count() == 0)
			return;

		debugSystemActive = true;

		foreach (var debugTerminal in debugTerminals) {
			debugTerminal.ContentType = ContentType.TEXT_AND_IMAGE;
			displayHeader(debugTerminal);
		}

		debugEventHandler.subscribe(this);
		program.Echo(debugTerminals.Count() + " debug terminal(s) reporting");
	}

	public void onNext(DebugEvent debugEvent) {
		write(debugEvent.message);
	}

	private void write(string text) {
		if (!debugSystemActive)
			return;

		foreach (var debugTerminal in debugTerminals) {
			debugTerminal.WriteText(DateTime.Now.ToString() + "\n", true);
			debugTerminal.WriteText(text + "\n\n", true);
		}
	}

	private void displayHeader(IMyTextPanel iMyTextPanel) {
		iMyTextPanel.WriteText("Spartan SMS Debug\n", false);
		iMyTextPanel.WriteText(debugTerminals.Count().ToString() + " debug terminal(s) reporting\n\n", true);
	}
}

public class LocalTerminal : Observer<OperatingMode>, Observer<SensorEvent> {
	private Queue<string> buffer = new Queue<string>();
	private string header = "Spartan SMS v0.1.0 [";
	private OperatingModeHandler operatingModeHandler;
	private IMyTextSurface textSurface;

	public LocalTerminal(OperatingModeHandler operatingModeHandler, SensorEventHandler sensorEventHandler, IMyTextSurface textSurface) {
		this.operatingModeHandler = operatingModeHandler;
		this.textSurface = textSurface;
		operatingModeHandler.subscribe(this);
		sensorEventHandler.subscribe(this);

		textSurface.ContentType = ContentType.TEXT_AND_IMAGE;
		displayHeader();
	}

	public void write(string text) {
		if (buffer.Count >= 8)
			buffer.Dequeue();

		buffer.Enqueue(text + "\n");
		displayHeader();

		if (buffer == null || buffer.Count == 0)
			return;

		foreach (var line in buffer)
			textSurface.WriteText(line, true);
	}

	public void onNext(OperatingMode operatingMode) {
		write("Change mode [" + operatingMode.convert(operatingMode.operatingModeType) + "]");
	}

	public void onNext(SensorEvent sensorEvent) {
		write("Event detected [" + sensorEvent.convert(sensorEvent.sensorEventType) + "]");
	}

	private void displayHeader() {
		textSurface.WriteText(header, false);
		textSurface.WriteText(operatingModeHandler.operatingMode.convert(operatingModeHandler.operatingMode.operatingModeType), true);
		textSurface.WriteText("]\n\n", true);
	}
}

public class LightingSystem : Observer<OperatingMode> {
	private List<IMyInteriorLight> interiorLights = new List<IMyInteriorLight>();
	private List<IMyInteriorLight> navigationLights = new List<IMyInteriorLight>();
	private Program program;

	public LightingSystem(Program program, OperatingModeHandler operatingModeHandler, LocalTerminal localTerminal) {
		this.program = program;

		operatingModeHandler.subscribe(this);

		program.GridTerminalSystem.GetBlocksOfType(interiorLights, light => !light.CustomData.Contains("nav"));
		program.GridTerminalSystem.GetBlocksOfType(navigationLights, light => light.CustomData.Contains("nav"));

		localTerminal.write("Lighting System initialized");
	}

	public void onNext(OperatingMode operatingMode) {
		switch (operatingMode.operatingModeType) {
			case OperatingModeType.UNDEFINED:
			break;

			case OperatingModeType.LONG_TERM_STANDBY:
			break;

			case OperatingModeType.STANDBY:
				foreach (var light in interiorLights) 
					light.SetValue<float>("Intensity", 5f);

				foreach (var light in navigationLights) {
					if (light.CustomData.Contains("beacon")) {
						light.SetValue<float>("Intensity", 5f);
						light.SetValue<float>("Blink Interval", 0.0f);
			
						continue;
					}

					light.ApplyAction("OnOff_Off");
				}
			break;

			case OperatingModeType.GROUND:
				foreach (var light in interiorLights)
					light.SetValue<float>("Intensity", 0.5f);

				foreach (var light in navigationLights) {
					if (light.CustomData.Contains("beacon")) {
						light.SetValue<float>("Intensity", 0.5f);
						light.SetValue<float>("Blink Interval", 0.0f);
			
						continue;
					}

					light.ApplyAction("OnOff_Off");
				}
			break;

			case OperatingModeType.FLIGHT:
				foreach (var light in interiorLights) 
					light.SetValue<float>("Intensity", 0.5f);

				foreach (var light in navigationLights) {
					if (light.CustomData.Contains("beacon")) {
						light.SetValue<float>("Intensity", 5f);
						light.SetValue<float>("Blink Interval", 0.9f);
			
						continue;
					}

					light.ApplyAction("OnOff_On");
				}
			break;

			default:
			break;
		}
	}
}

public class ThrustSystem : Observer<OperatingMode> {
	private List<IMyThrust> thrusters = new List<IMyThrust>();
	private Program program;

	public ThrustSystem(Program program, OperatingModeHandler operatingModeHandler, LocalTerminal localTerminal) {
		this.program = program;

		operatingModeHandler.subscribe(this);

		program.GridTerminalSystem.GetBlocksOfType(thrusters);
		localTerminal.write("Thrust System initialized");
	}

	public void onNext(OperatingMode operatingMode) {
		switch (operatingMode.operatingModeType) {
			case OperatingModeType.UNDEFINED:
			break;

			case OperatingModeType.LONG_TERM_STANDBY:
			break;

			case OperatingModeType.STANDBY:
				foreach (var thruster in thrusters)
					thruster.ApplyAction("OnOff_Off");
			break;

			case OperatingModeType.GROUND:
				foreach (var thruster in thrusters)
					thruster.ApplyAction("OnOff_Off");
			break;

			case OperatingModeType.FLIGHT:
				foreach (var thruster in thrusters)
					thruster.ApplyAction("OnOff_On");
			break;

			default:
			break;
		}
	}
}

public class WheelSystem : Observer<OperatingMode>, Observer<SensorEvent> {
	private List<IMyMotorSuspension> wheels = new List<IMyMotorSuspension>();
	private List<IMyShipController> cockpits = new List<IMyShipController>();
	private float desiredWheelHeight = -1.0f;
	private Program program;

	public WheelSystem(Program program, OperatingModeHandler operatingModeHandler, SensorEventHandler sensorEventHandler, LocalTerminal localTerminal) {
		this.program = program;

		operatingModeHandler.subscribe(this);
		sensorEventHandler.subscribe(this);

		program.GridTerminalSystem.GetBlocksOfType(wheels);
		program.GridTerminalSystem.GetBlocksOfType(cockpits);
		localTerminal.write("Wheel System initialized");
	}

	public void onNext(OperatingMode operatingMode) {
		switch (operatingMode.operatingModeType) {
			case OperatingModeType.UNDEFINED:
			break;

			case OperatingModeType.LONG_TERM_STANDBY:
			break;

			case OperatingModeType.STANDBY:
				foreach (var wheel in wheels)
					wheel.ApplyAction("OnOff_Off");

				//if (cockpits.Count() > 0 && !cockpits[0].GetValue<bool>("Handbrake"))
				//	cockpits[0].SetValue<bool>("HandBrake", true);
			break;

			case OperatingModeType.GROUND:
				foreach (var wheel in wheels)
					wheel.ApplyAction("OnOff_On");

				//if (cockpits.Count() > 0 && cockpits[0].GetValue<bool>("Handbrake"))
				//	cockpits[0].SetValue<bool>("HandBrake", true);
			break;

			case OperatingModeType.FLIGHT:
				foreach (var wheel in wheels)
					wheel.ApplyAction("OnOff_On");

				//if (cockpits.Count() > 0 && cockpits[0].GetValue<bool>("Handbrake"))
				//	cockpits[0].SetValue<bool>("HandBrake", true);
			break;

			default:
			break;
		}
	}

	public void onNext(SensorEvent sensorEvent) {
		switch (sensorEvent.sensorEventType) {
			case SensorEventType.UNDEFINED:
			break;

			case SensorEventType.TAKEOFF:
				program.desiredWheelHeight = 1.02f;
				program.Runtime.UpdateFrequency = UpdateFrequency.Update10;
			break;

			case SensorEventType.APPROACH:
				program.desiredWheelHeight = -1.0f;
				program.Runtime.UpdateFrequency = UpdateFrequency.Update10;
			break;

			default:
			break;
		}
	}
}


public class GyroscopeSystem : Observer<OperatingMode> {
	private List<IMyGyro> gyroscopes = new List<IMyGyro>();
	private Program program;

	public GyroscopeSystem(Program program, OperatingModeHandler operatingModeHandler, LocalTerminal localTerminal) {
		this.program = program;

		operatingModeHandler.subscribe(this);

		program.GridTerminalSystem.GetBlocksOfType(gyroscopes);
		localTerminal.write("Gyroscope System initialized");
	}

	public void onNext(OperatingMode operatingMode) {
		switch (operatingMode.operatingModeType) {
			case OperatingModeType.UNDEFINED:
			break;

			case OperatingModeType.LONG_TERM_STANDBY:
			break;

			case OperatingModeType.STANDBY:
				foreach (var gyroscope in gyroscopes)
					gyroscope.ApplyAction("OnOff_Off");
			break;

			case OperatingModeType.GROUND:
				foreach (var gyroscope in gyroscopes)
					gyroscope.ApplyAction("OnOff_Off");
			break;

			case OperatingModeType.FLIGHT:
				foreach (var gyroscope in gyroscopes)
					gyroscope.ApplyAction("OnOff_On");
			break;

			default:
			break;
		}
	}
}

public class ReactorSystem : Observer<OperatingMode> {
	private List<IMyReactor> reactors = new List<IMyReactor>();
	private Program program;

	public ReactorSystem(Program program, OperatingModeHandler operatingModeHandler, LocalTerminal localTerminal) {
		this.program = program;

		operatingModeHandler.subscribe(this);

		program.GridTerminalSystem.GetBlocksOfType(reactors);
		localTerminal.write("Reactor System initialized");
	}

	public void onNext(OperatingMode operatingMode) {
		switch (operatingMode.operatingModeType) {
			case OperatingModeType.UNDEFINED:
			break;

			case OperatingModeType.LONG_TERM_STANDBY:
			break;

			case OperatingModeType.STANDBY:
				foreach (var reactor in reactors)
					reactor.ApplyAction("OnOff_Off");
			break;

			case OperatingModeType.GROUND:
				foreach (var reactor in reactors)
					reactor.ApplyAction("OnOff_On");
			break;

			case OperatingModeType.FLIGHT:
				foreach (var reactor in reactors)
					reactor.ApplyAction("OnOff_On");
			break;

			default:
			break;
		}
	}
}

public class SpartanServiceLocator {

}

// Temp
private List<IMyMotorSuspension> wheels = new List<IMyMotorSuspension>();
private float desiredWheelHeight = -1.0f;


private DebugEventHandler debugEventHandler;
private DebugTerminal debugTerminal;
private OperatingModeHandler operatingModeHandler;
private SensorEventHandler sensorEventHandler;
private LocalTerminal localTerminal;
private LightingSystem lightingSystem;
private ThrustSystem thrustSystem;
private WheelSystem wheelSystem;
private GyroscopeSystem gyroscopeSystem;
private ReactorSystem reactorSystem;

public Program() {
	Echo("Spartan Ship Management System");

	try {
		Echo("Instantiating Debugging System");
	
		debugEventHandler = new DebugEventHandler();
		debugTerminal = new DebugTerminal(this, debugEventHandler);
	} catch (Exception e) {
		Echo("[SEVERE] Failed to instantiate Debugging System");
		Echo(e.ToString());
	}

	try {
		// Temp
		GridTerminalSystem.GetBlocksOfType(wheels);

		Echo("\nPerforming deserialization");
		//Deserializer deserializer = new Deserializer("OperatingMode:mode=GROUND;\n");
		//deserializer.toClass(operatingMode);

		Echo("\nInitializing Operating Mode Handler");
		operatingModeHandler = new OperatingModeHandler();

		Echo("                  Sensor Event Handler");
		sensorEventHandler = new SensorEventHandler(operatingModeHandler, localTerminal);

		Echo("                  Local Terminal");
		localTerminal = new LocalTerminal(operatingModeHandler, sensorEventHandler, Me.GetSurface(0));

		lightingSystem = new LightingSystem(this, operatingModeHandler, localTerminal);
		thrustSystem = new ThrustSystem(this, operatingModeHandler, localTerminal);
		wheelSystem = new WheelSystem(this, operatingModeHandler, sensorEventHandler, localTerminal);
		gyroscopeSystem = new GyroscopeSystem(this, operatingModeHandler, localTerminal);
		reactorSystem = new ReactorSystem(this, operatingModeHandler, localTerminal);

		localTerminal.write("Ready.");
	} catch (Exception e) {
		debugEventHandler.fire(new DebugEvent(e.ToString()));
	} finally {
		checkInstructionCountUtilization();
	}
}

public void Save() {
	//Serializer serializer = new Serializer();
	//serializer.append(operatingMode);
	
	//Storage = serializer.toString();
}

public void Main(string argument, UpdateType updateType) {
	try {
		if ((updateType & (UpdateType.Trigger | UpdateType.Terminal)) != 0)
			oneTimeInstruction(argument);

		if ((updateType & UpdateType.Update10) != 0)
			runContinuousLogic();
	} catch (Exception e) {
		debugEventHandler.fire(new DebugEvent(e.ToString()));
	} finally {
		checkInstructionCountUtilization();
	}
}

private void runContinuousLogic() {
	foreach (var thisWheel in wheels) {
		float thisHeight = thisWheel.GetValue<float>("Height");
                   
		if (Math.Abs(thisHeight + desiredWheelHeight) > 2.0f) {
			Runtime.UpdateFrequency = UpdateFrequency.Once;
			continue;
		}

		if (thisHeight < desiredWheelHeight)
				thisWheel.SetValue<float>("Height", thisHeight + 0.05f);
		else
				thisWheel.SetValue<float>("Height", thisHeight - 0.05f);
	}
}

private void oneTimeInstruction(string instruction) {
	switch (instruction) {
		case "mode standby":
			operatingModeHandler.change(OperatingModeType.STANDBY);
		break;

		case "mode ground":
			operatingModeHandler.change(OperatingModeType.GROUND);
		break;

		case "mode flight":
			operatingModeHandler.change(OperatingModeType.FLIGHT);
		break;

		case "event takeoff":
			sensorEventHandler.fire(new SensorEvent(SensorEventType.TAKEOFF));
		break;

		case "event approach":
			sensorEventHandler.fire(new SensorEvent(SensorEventType.APPROACH));
		break;

		default:
			localTerminal.write("Unknown instruction [" + instruction + "]");
		break;
	}
}

private void checkInstructionCountUtilization() {
	float instructionCountUtilization = ((float) Runtime.CurrentInstructionCount / (float) Runtime.MaxInstructionCount) * 100f;

	if (instructionCountUtilization >= 60f)
		debugEventHandler.fire(new DebugEvent(instructionCountUtilization.ToString("0.000") + "% instruction count utilization"));
}
